import random 
from datetime import datetime, timedelta 
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update, InputMediaPhoto 
from telegram.ext import CallbackContext, CommandHandler, CallbackQueryHandler 
from shivu import application, db, user_collection 
 
collection = db['anime_characters_lol'] 
luv_config_collection = db['luv_config'] 
sudo_users = ["8297659126", "8420981179", "5147822244"] 
 
DEFAULT_CONFIG = { 
    "rarities": { 
        "üü¢ Common": {"weight": 60, "price": 2000}, 
        "üü£ Rare": {"weight": 25, "price": 5000}, 
        "üü° Legendary": {"weight": 10, "price": 10000}, 
        "üíÆ Special Edition": {"weight": 5, "price": 25000} 
    }, 
    "refresh_cost": 20000, 
    "refresh_limit": 2, 
    "store_items": 3, 
    "cooldown_hours": 24 
} 
 
async def get_config(): 
    cfg = await luv_config_collection.find_one({"_id": "luv_config"}) 
    if not cfg: 
        await luv_config_collection.insert_one({"_id": "luv_config", **DEFAULT_CONFIG}) 
        return DEFAULT_CONFIG 
    return cfg 
 
async def get_rarity(cfg): 
    rarities = cfg['rarities'] 
    return random.choices(list(rarities.keys()), [rarities[r]['weight'] for r in rarities], k=1)[0] 
 
async def generate_chars(uid, cfg): 
    chars = [] 
    for _ in range(cfg.get('store_items', 3)): 
        rarity = await get_rarity(cfg) 
        pipe = [{'$match': {'rarity': rarity}}, {'$sample': {'size': 1}}] 
        char = await collection.aggregate(pipe).to_list(length=1) 
        if char: 
            chars.append(char[0]) 
    return chars 
 
async def get_luv_data(uid): 
    user = await user_collection.find_one({"id": uid}) 
    return user.get('private_store', {'characters': [], 'last_reset': None, 'refresh_count': 0, 'purchased': []}) if user else None 
 
async def update_luv_data(uid, data): 
    await user_collection.update_one({"id": uid}, {"$set": {"private_store": data}}, upsert=True) 
 
def time_left(target): 
    if not target: 
        return "·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á …¥·¥è·¥°" 
    if isinstance(target, str): 
        target = datetime.fromisoformat(target) 
    diff = target - datetime.utcnow() 
    if diff.total_seconds() <= 0: 
        return "·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á …¥·¥è·¥°" 
    h, m = int(diff.total_seconds() // 3600), int((diff.total_seconds() % 3600) // 60) 
    return f"{h} ú {m}·¥ç" 
 
async def build_caption(char, cfg, page, total, luv_data, balance): 
    cid = char.get("id") or char.get("_id") 
    name = char.get("name", "Unknown") 
    anime = char.get("anime", "Unknown") 
    rarity = char.get("rarity", "Unknown") 
    price = cfg['rarities'].get(rarity, {}).get('price', 0) 
 
    refresh_left = max(0, cfg.get('refresh_limit', 2) - luv_data.get('refresh_count', 0)) 
    last_reset = luv_data.get('last_reset') 
    if last_reset: 
        if isinstance(last_reset, str): 
            last_reset = datetime.fromisoformat(last_reset) 
        next_reset = last_reset + timedelta(hours=cfg.get('cooldown_hours', 24)) 
        time_rem = time_left(next_reset) 
    else: 
        time_rem = "·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á …¥·¥è·¥°" 
 
    purchased = luv_data.get('purchased', []) 
    status = "‚äó ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥è·¥°…¥·¥á·¥Ö" if cid in purchased else f"‚äô {price} …¢·¥è ü·¥Ö" 
 
    return ( 
        f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n" 
        f"‚îÇ   Ôº∞Ôº≤Ôº©Ôº∂Ôº°Ôº¥Ôº• Ôº≥Ôº¥ÔºØÔº≤Ôº•   ‚îÇ\n" 
        f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n" 
        f"‚ü° …¥·¥Ä·¥ç·¥á: <b>{name}</b>\n" 
        f"‚ü° ·¥Ä…¥…™·¥ç·¥á: <code>{anime}</code>\n" 
        f"‚ü°  Ä·¥Ä Ä…™·¥õ è: {rarity}\n" 
        f"‚ü° ·¥ò Ä…™·¥Ñ·¥á: {status}\n" 
        f"‚ü° …™·¥Ö: <code>{cid}</code>\n\n" 
        f"‚ü°  Ä·¥á“ì Ä·¥áÍú± ú·¥áÍú±  ü·¥áÍú∞·¥õ: {refresh_left}/{cfg.get('refresh_limit', 2)}\n" 
        f"‚ü° …¥·¥áx·¥õ  Ä·¥áÍú±·¥á·¥õ: {time_rem}\n\n" 
        f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" 
        f"‚ü° ·¥ò·¥Ä…¢·¥á: {page}/{total}\n" 
        f"‚ü°  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á: {balance} …¢·¥è ü·¥Ö" 
    ), char.get("img_url", ""), price, cid in purchased 
 
async def luv(update: Update, context: CallbackContext): 
    uid = update.effective_user.id 
    cfg = await get_config() 
    user = await user_collection.find_one({"id": uid}) 
 
    if not user: 
        await update.message.reply_text("‚äó Íú±·¥õ·¥Ä Ä·¥õ ·¥õ ú·¥á  ô·¥è·¥õ Íú∞…™ ÄÍú±·¥õ! ·¥úÍú±·¥á /start") 
        return 
 
    balance = user.get('balance', 0) 
    luv_data = await get_luv_data(uid) 
 
    cooldown = cfg.get('cooldown_hours', 24) 
    last_reset = luv_data.get('last_reset') 
    needs_reset = True 
 
    if last_reset: 
        if isinstance(last_reset, str): 
            last_reset = datetime.fromisoformat(last_reset) 
        needs_reset = (datetime.utcnow() - last_reset).total_seconds() >= (cooldown * 3600) 
 
    if needs_reset or not luv_data.get('characters'): 
        chars = await generate_chars(uid, cfg) 
        if not chars: 
            await update.message.reply_text("‚äó Íú∞·¥Ä…™ ü·¥á·¥Ö ·¥õ·¥è …¢·¥á…¥·¥á Ä·¥Ä·¥õ·¥á Íú±·¥õ·¥è Ä·¥á") 
            return 
        luv_data = {'characters': chars, 'last_reset': datetime.utcnow().isoformat(), 'refresh_count': 0, 'purchased': []} 
        await update_luv_data(uid, luv_data) 
 
    chars = luv_data.get('characters', []) 
    if not chars: 
        await update.message.reply_text("‚äó …¥·¥è ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú± ·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á") 
        return 
 
    context.user_data['luv_page'] = 0 
    context.user_data['luv_chars'] = chars 
 
    char = chars[0] 
    caption, img, price, owned = await build_caption(char, cfg, 1, len(chars), luv_data, balance) 
    cid = char.get("id") or char.get("_id") 
 
    btns = [] 
    if not owned: 
        btns.append([InlineKeyboardButton("‚äô  ô·¥ú è", callback_data=f"luv_buy_{cid}")]) 
 
    nav = [] 
    if len(chars) > 1: 
        refresh_left = max(0, cfg.get('refresh_limit', 2) - luv_data.get('refresh_count', 0)) 
        nav.append(InlineKeyboardButton("‚ü≤  Ä·¥á“ì Ä·¥áÍú± ú" if refresh_left > 0 else "‚ü≤ ·¥úÍú±·¥á·¥Ö",  
                                        callback_data="luv_refresh" if refresh_left > 0 else "luv_nope")) 
        nav.append(InlineKeyboardButton("…¥·¥áx·¥õ ‚ä≥", callback_data="luv_page_1")) 
        btns.append(nav) 
    else: 
        refresh_left = max(0, cfg.get('refresh_limit', 2) - luv_data.get('refresh_count', 0)) 
        btns.append([InlineKeyboardButton("‚ü≤  Ä·¥á“ì Ä·¥áÍú± ú" if refresh_left > 0 else "‚ü≤ ·¥úÍú±·¥á·¥Ö",  
                                         callback_data="luv_refresh" if refresh_left > 0 else "luv_nope")]) 
 
    btns.append([InlineKeyboardButton("‚äó ·¥Ñ ü·¥èÍú±·¥á", callback_data="luv_close")]) 
 
    msg = await update.message.reply_photo(photo=img, caption=caption, parse_mode="HTML",  
                                           reply_markup=InlineKeyboardMarkup(btns)) 
    context.user_data['luv_msg_id'] = msg.message_id 
 
async def luv_callback(update: Update, context: CallbackContext): 
    q = update.callback_query 
    await q.answer() 
    uid = q.from_user.id 
    data = q.data 
    cfg = await get_config() 
 
    async def render_page(page): 
        chars = context.user_data.get('luv_chars', []) 
        if not chars or page >= len(chars): 
            await q.answer("‚äó …™…¥·¥†·¥Ä ü…™·¥Ö ·¥ò·¥Ä…¢·¥á", show_alert=True) 
            return 
 
        context.user_data['luv_page'] = page 
        char = chars[page] 
        user = await user_collection.find_one({"id": uid}) 
        balance = user.get('balance', 0) if user else 0 
        luv_data = await get_luv_data(uid) 
 
        caption, img, price, owned = await build_caption(char, cfg, page + 1, len(chars), luv_data, balance) 
        cid = char.get("id") or char.get("_id") 
 
        btns = [] 
        if not owned: 
            btns.append([InlineKeyboardButton("‚äô  ô·¥ú è", callback_data=f"luv_buy_{cid}")]) 
 
        nav = [] 
        if len(chars) > 1: 
            if page > 0: 
                nav.append(InlineKeyboardButton("‚ä≤ ·¥ò Ä·¥á·¥†", callback_data=f"luv_page_{page-1}")) 
            refresh_left = max(0, cfg.get('refresh_limit', 2) - luv_data.get('refresh_count', 0)) 
            nav.append(InlineKeyboardButton("‚ü≤  Ä·¥á“ì Ä·¥áÍú± ú" if refresh_left > 0 else "‚ü≤ ·¥úÍú±·¥á·¥Ö",  
                                           callback_data="luv_refresh" if refresh_left > 0 else "luv_nope")) 
            if page < len(chars) - 1: 
                nav.append(InlineKeyboardButton("…¥·¥áx·¥õ ‚ä≥", callback_data=f"luv_page_{page+1}")) 
            btns.append(nav) 
 
        btns.append([InlineKeyboardButton("‚äó ·¥Ñ ü·¥èÍú±·¥á", callback_data="luv_close")]) 
 
        try: 
            await q.edit_message_media(media=InputMediaPhoto(media=img, caption=caption, parse_mode="HTML"), 
                                       reply_markup=InlineKeyboardMarkup(btns)) 
        except: 
            try: 
                await q.edit_message_caption(caption=caption, parse_mode="HTML",  
                                            reply_markup=InlineKeyboardMarkup(btns)) 
            except: 
                pass 
 
    if data.startswith("luv_page_"): 
        await render_page(int(data.split("_")[2])) 
 
    elif data == "luv_refresh": 
        user = await user_collection.find_one({"id": uid}) 
        if not user: 
            await q.answer("‚äó ·¥úÍú±·¥á Ä …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö", show_alert=True) 
            return 
 
        luv_data = await get_luv_data(uid) 
        refresh_left = max(0, cfg.get('refresh_limit', 2) - luv_data.get('refresh_count', 0)) 
 
        if refresh_left <= 0: 
            await q.answer("‚äó …¥·¥è  Ä·¥á“ì Ä·¥áÍú± ú·¥áÍú±  ü·¥áÍú∞·¥õ!", show_alert=True) 
            return 
 
        cost = cfg.get('refresh_cost', 20000) 
        balance = user.get('balance', 0) 
 
        if balance < cost: 
            await q.answer(f"‚äó …¥·¥á·¥á·¥Ö {cost} …¢·¥è ü·¥Ö!", show_alert=True) 
            return 
 
        btns = [[InlineKeyboardButton("‚úì ·¥Ñ·¥è…¥Íú∞…™ Ä·¥ç", callback_data="luv_ref_ok"), 
                 InlineKeyboardButton("‚úó ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü", callback_data="luv_ref_no")]] 
 
        await q.edit_message_caption( 
            caption=f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n" 
                    f"‚îÇ   Ôº£ÔºØÔºÆÔº¶Ôº©Ôº≤Ôº≠ Ôº≤Ôº•Ôº¶Ôº≤Ôº•Ôº≥Ôº®   ‚îÇ\n" 
                    f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n" 
                    f"‚ü° ·¥Ñ·¥èÍú±·¥õ: <b>{cost}</b> …¢·¥è ü·¥Ö\n" 
                    f"‚ü°  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á: <b>{balance}</b> …¢·¥è ü·¥Ö\n" 
                    f"‚ü°  Ä·¥áÍú∞ Ä·¥áÍú± ú·¥áÍú±  ü·¥áÍú∞·¥õ: {refresh_left-1}/{cfg.get('refresh_limit', 2)}\n\n" 
                    f"…¢·¥á…¥·¥á Ä·¥Ä·¥õ·¥á 3 …¥·¥á·¥°  Ä·¥Ä…¥·¥Ö·¥è·¥ç ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±?", 
            parse_mode="HTML", 
            reply_markup=InlineKeyboardMarkup(btns) 
        ) 
 
    elif data == "luv_ref_ok": 
        user = await user_collection.find_one({"id": uid}) 
        luv_data = await get_luv_data(uid) 
        cost = cfg.get('refresh_cost', 20000) 
        balance = user.get('balance', 0) 
 
        if balance < cost: 
            await q.answer("‚äó …™…¥Íú±·¥úÍú∞Íú∞…™·¥Ñ…™·¥á…¥·¥õ  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á!", show_alert=True) 
            return 
 
        await user_collection.update_one({"id": uid}, {"$inc": {"balance": -cost}}) 
 
        # Refresh animation 
        await q.edit_message_caption( 
            caption="‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n" 
                    "‚îÇ   ‚ü≤ Ôº≤Ôº•Ôº¶Ôº≤Ôº•Ôº≥Ôº®Ôº©ÔºÆÔºß...   ‚îÇ\n" 
                    "‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n" 
                    "‚ü° …¢·¥á…¥·¥á Ä·¥Ä·¥õ…™…¥…¢ …¥·¥á·¥° ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±...", 
            parse_mode="HTML" 
        ) 
 
        chars = await generate_chars(uid, cfg) 
        if not chars: 
            await q.answer("‚äó Íú∞·¥Ä…™ ü·¥á·¥Ö ·¥õ·¥è …¢·¥á…¥·¥á Ä·¥Ä·¥õ·¥á", show_alert=True) 
            return 
 
        luv_data['characters'] = chars 
        luv_data['refresh_count'] = luv_data.get('refresh_count', 0) + 1 
        luv_data['purchased'] = [] 
        await update_luv_data(uid, luv_data) 
 
        context.user_data['luv_chars'] = chars 
        context.user_data['luv_page'] = 0 
 
        await q.answer("‚úì Íú±·¥õ·¥è Ä·¥á  Ä·¥á“ì Ä·¥áÍú± ú·¥á·¥Ö!") 
        await render_page(0) 
 
    elif data == "luv_ref_no": 
        await render_page(context.user_data.get('luv_page', 0)) 
 
    elif data == "luv_nope": 
        await q.answer("‚äó …¥·¥è  Ä·¥á“ì Ä·¥áÍú± ú·¥áÍú±  ü·¥áÍú∞·¥õ!", show_alert=True) 
 
    elif data.startswith("luv_buy_"): 
        cid = data.split("_", 2)[2] 
        chars = context.user_data.get('luv_chars', []) 
        char = next((c for c in chars if (c.get("id") or c.get("_id")) == cid), None) 
 
        if not char: 
            await q.answer("‚äó ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á Ä …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö", show_alert=True) 
            return 
 
        luv_data = await get_luv_data(uid) 
        if cid in luv_data.get('purchased', []): 
            await q.answer("‚äó ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥ò·¥ú Ä·¥Ñ ú·¥ÄÍú±·¥á·¥Ö!", show_alert=True) 
            return 
 
        rarity = char.get('rarity', 'Unknown') 
        price = cfg['rarities'].get(rarity, {}).get('price', 0) 
 
        btns = [[InlineKeyboardButton("‚úì ·¥Ñ·¥è…¥Íú∞…™ Ä·¥ç", callback_data=f"luv_ok_{cid}"), 
                 InlineKeyboardButton("‚úó ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü", callback_data="luv_buy_no")]] 
 
        await q.edit_message_caption( 
            caption=f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n" 
                    f"‚îÇ   Ôº£ÔºØÔºÆÔº¶Ôº©Ôº≤Ôº≠ Ôº∞ÔºµÔº≤Ôº£Ôº®Ôº°Ôº≥Ôº•   ‚îÇ\n" 
                    f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n" 
                    f"‚ü° …¥·¥Ä·¥ç·¥á: <b>{char['name']}</b>\n" 
                    f"‚ü°  Ä·¥Ä Ä…™·¥õ è: {rarity}\n" 
                    f"‚ü° ·¥ò Ä…™·¥Ñ·¥á: <b>{price}</b> …¢·¥è ü·¥Ö\n\n" 
                    f"·¥Ñ·¥è…¥Íú∞…™ Ä·¥ç ·¥ò·¥ú Ä·¥Ñ ú·¥ÄÍú±·¥á?", 
            parse_mode="HTML", 
            reply_markup=InlineKeyboardMarkup(btns) 
        ) 
 
    elif data.startswith("luv_ok_"): 
        cid = data.split("_", 2)[2] 
        chars = context.user_data.get('luv_chars', []) 
        char = next((c for c in chars if (c.get("id") or c.get("_id")) == cid), None) 
 
        if not char: 
            await q.answer("‚äó ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á Ä …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö", show_alert=True) 
            return 
 
        user = await user_collection.find_one({"id": uid}) 
        luv_data = await get_luv_data(uid) 
 
        if cid in luv_data.get('purchased', []): 
            await q.answer("‚äó ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥ò·¥ú Ä·¥Ñ ú·¥ÄÍú±·¥á·¥Ö!", show_alert=True) 
            return 
 
        rarity = char.get('rarity', 'Unknown') 
        price = cfg['rarities'].get(rarity, {}).get('price', 0) 
        balance = user.get('balance', 0) 
 
        if balance < price: 
            await q.answer("‚äó …™…¥Íú±·¥úÍú∞Íú∞…™·¥Ñ…™·¥á…¥·¥õ  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á!", show_alert=True) 
            await q.edit_message_caption( 
                caption=f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n" 
                        f"‚îÇ   ‚äó …™…¥Íú±·¥úÍú∞Íú∞…™·¥Ñ…™·¥á…¥·¥õ …¢·¥è ü·¥Ö   ‚îÇ\n" 
                        f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n" 
                        f"‚ü° …¥·¥á·¥á·¥Ö: <b>{price}</b> …¢·¥è ü·¥Ö\n" 
                        f"‚ü°  ú·¥Ä·¥†·¥á: <b>{balance}</b> …¢·¥è ü·¥Ö\n\n" 
                        f"·¥úÍú±·¥á /bal ·¥õ·¥è ·¥Ñ ú·¥á·¥Ñ·¥ã  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á", 
                parse_mode="HTML" 
            ) 
            return 
 
        # Purchase 
        await user_collection.update_one({"id": uid},  
                                         {"$inc": {"balance": -price}, "$push": {"characters": char}}) 
 
        if 'purchased' not in luv_data: 
            luv_data['purchased'] = [] 
        luv_data['purchased'].append(cid) 
        await update_luv_data(uid, luv_data) 
 
        btns = [[InlineKeyboardButton("‚äô ·¥ç·¥Ä…™…¥ Íú± ú·¥è·¥ò", callback_data="luv_main"), 
                 InlineKeyboardButton("‚äó ·¥Ñ ü·¥èÍú±·¥á", callback_data="luv_close")]] 
 
        await q.edit_message_caption( 
            caption=f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n" 
                    f"‚îÇ   ‚úì Ôº∞ÔºµÔº≤Ôº£Ôº®Ôº°Ôº≥Ôº• Ôº≥ÔºµÔº£Ôº£Ôº•Ôº≥Ôº≥   ‚îÇ\n" 
                    f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n" 
                    f"‚ü° …¥·¥Ä·¥ç·¥á: <b>{char['name']}</b>\n" 
                    f"‚ü° ·¥ò·¥Ä…™·¥Ö: <b>{price}</b> …¢·¥è ü·¥Ö\n" 
                    f"‚ü°  Ä·¥á·¥ç·¥Ä…™…¥…™…¥…¢: <b>{balance - price}</b> …¢·¥è ü·¥Ö\n\n" 
                    f"·¥Ä·¥Ö·¥Ö·¥á·¥Ö ·¥õ·¥è  è·¥è·¥ú Ä  ú·¥Ä Ä·¥á·¥ç!", 
            parse_mode="HTML", 
            reply_markup=InlineKeyboardMarkup(btns) 
        ) 
        await q.answer("‚úì ·¥ò·¥ú Ä·¥Ñ ú·¥ÄÍú±·¥á·¥Ö!") 
 
    elif data == "luv_buy_no": 
        await render_page(context.user_data.get('luv_page', 0)) 
 
    elif data == "luv_main": 
        await render_page(0) 
 
    elif data == "luv_close": 
        try: 
            await q.message.delete() 
        except: 
            await q.edit_message_caption("Íú±·¥õ·¥è Ä·¥á ·¥Ñ ü·¥èÍú±·¥á·¥Ö") 
 
# Admin commands 
async def luv_view(update: Update, context: CallbackContext): 
    if str(update.effective_user.id) not in sudo_users: 
        return 
    cfg = await get_config() 
    rarities = "\n".join([f"‚ü° {r}: {d['weight']}% | {d['price']}g" for r, d in cfg['rarities'].items()]) 
    await update.message.reply_text( 
        f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ    ü·¥ú·¥† ·¥Ñ·¥è…¥Íú∞…™…¢   ‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n" 
        f"‚ü°  Ä·¥á“ì Ä·¥áÍú± ú ·¥Ñ·¥èÍú±·¥õ: {cfg.get('refresh_cost')}\n" 
        f"‚ü°  Ä·¥á“ì Ä·¥áÍú± ú  ü…™·¥ç…™·¥õ: {cfg.get('refresh_limit')}\n" 
        f"‚ü° …™·¥õ·¥á·¥çÍú±: {cfg.get('store_items')}\n" 
        f"‚ü° ·¥Ñ·¥è·¥è ü·¥Ö·¥è·¥°…¥: {cfg.get('cooldown_hours')} ú\n\n{rarities}", 
        parse_mode="HTML" 
    ) 
 
async def luv_stats(update: Update, context: CallbackContext): 
    uid = update.effective_user.id 
    user = await user_collection.find_one({"id": uid}) 
    if not user: 
        await update.message.reply_text("‚äó ·¥úÍú±·¥á /start Íú∞…™ ÄÍú±·¥õ") 
        return 
 
    luv_data = await get_luv_data(uid) 
    cfg = await get_config() 
    refresh_left = max(0, cfg.get('refresh_limit', 2) - luv_data.get('refresh_count', 0)) 
 
    last_reset = luv_data.get('last_reset') 
    if last_reset: 
        if isinstance(last_reset, str): 
            last_reset = datetime.fromisoformat(last_reset) 
        next_reset = last_reset + timedelta(hours=cfg.get('cooldown_hours', 24)) 
        time_rem = time_left(next_reset) 
    else: 
        time_rem = "·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á …¥·¥è·¥°" 
 
    await update.message.reply_text( 
        f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ    è·¥è·¥ú Ä  ü·¥ú·¥† Íú±·¥õ·¥Ä·¥õÍú±   ‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n" 
        f"‚ü° ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±: {len(luv_data.get('characters', []))}\n" 
        f"‚ü°  Ä·¥á“ì Ä·¥áÍú± ú·¥áÍú±: {refresh_left}/{cfg.get('refresh_limit', 2)}\n" 
        f"‚ü° …¥·¥áx·¥õ  Ä·¥áÍú±·¥á·¥õ: {time_rem}\n" 
        f"‚ü°  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á: {user.get('balance', 0)} …¢·¥è ü·¥Ö\n\n" 
        f"·¥úÍú±·¥á /luv ·¥õ·¥è ·¥è·¥ò·¥á…¥ Íú±·¥õ·¥è Ä·¥á!", 
        parse_mode="HTML" 
    ) 
 
async def luv_help(update: Update, context: CallbackContext): 
    msg = ( 
        f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ    ü·¥ú·¥†  ú·¥á ü·¥ò   ‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n" 
        f"<b>·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú±:</b>\n" 
        f"‚ü° /luv - ·¥è·¥ò·¥á…¥ Íú±·¥õ·¥è Ä·¥á\n" 
        f"‚ü° /luvstats - ·¥†…™·¥á·¥° Íú±·¥õ·¥Ä·¥õÍú±\n\n" 
        f"<b> ú·¥è·¥° …™·¥õ ·¥°·¥è Ä·¥ãÍú±:</b>\n" 
        f"‚ü° …¢·¥á·¥õ 3  Ä·¥Ä…¥·¥Ö·¥è·¥ç ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú± ·¥á·¥†·¥á Ä è 24 ú\n" 
        f"‚ü°  Ä·¥á“ì Ä·¥áÍú± ú ·¥ú·¥ò ·¥õ·¥è 2x (·¥Ñ·¥èÍú±·¥õÍú± …¢·¥è ü·¥Ö)\n" 
        f"‚ü°  ô·¥ú è ·¥°…™·¥õ ú …¢·¥è ü·¥Ö\n" 
        f"‚ü° ·¥Ä·¥ú·¥õ·¥è  Ä·¥áÍú±·¥á·¥õ ·¥ÄÍú∞·¥õ·¥á Ä ·¥Ñ·¥è·¥è ü·¥Ö·¥è·¥°…¥" 
    ) 
 
    uid = update.effective_user.id 
    if str(uid) in sudo_users: 
        msg += ( 
            f"\n\n<b>·¥Ä·¥Ö·¥ç…™…¥:</b>\n" 
            f"‚ü° /luvview - ·¥†…™·¥á·¥° ·¥Ñ·¥è…¥Íú∞…™…¢\n" 
            f"‚ü° /luvconfig <key> <val>\n" 
            f"‚ü° /luvrarity <name> <w> <p>\n" 
            f"‚ü° /luvreset <uid>" 
        ) 
 
    await update.message.reply_text(msg, parse_mode="HTML") 
 
async def luv_config(update: Update, context: CallbackContext): 
    if str(update.effective_user.id) not in sudo_users: 
        return 
 
    if len(context.args) < 2: 
        await update.message.reply_text("‚äó ·¥úÍú±·¥Ä…¢·¥á: /luvconfig <key> <value>\n·¥ã·¥á èÍú±: refresh_cost, refresh_limit, store_items, cooldown_hours") 
        return 
 
    try: 
        key, val = context.args[0], int(context.args[1]) 
        if key not in ['refresh_cost', 'refresh_limit', 'store_items', 'cooldown_hours']: 
            await update.message.reply_text("‚äó …™…¥·¥†·¥Ä ü…™·¥Ö ·¥ã·¥á è") 
            return 
 
        cfg = await get_config() 
        cfg[key] = val 
        await luv_config_collection.update_one({"_id": "luv_config"}, {"$set": cfg}, upsert=True) 
        await update.message.reply_text(f"‚úì {key} = {val}", parse_mode="HTML") 
    except: 
        await update.message.reply_text("‚äó …™…¥·¥†·¥Ä ü…™·¥Ö ·¥†·¥Ä ü·¥ú·¥á") 
 
async def luv_rarity(update: Update, context: CallbackContext): 
    if str(update.effective_user.id) not in sudo_users: 
        return 
 
    if len(context.args) < 3: 
        await update.message.reply_text("‚äó ·¥úÍú±·¥Ä…¢·¥á: /luvrarity <name> <weight> <price>") 
        return 
 
    try: 
        name = " ".join(context.args[:-2]) 
        weight, price = int(context.args[-2]), int(context.args[-1]) 
 
        cfg = await get_config() 
        if name not in cfg['rarities']: 
            cfg['rarities'][name] = {} 
        cfg['rarities'][name] = {'weight': weight, 'price': price} 
 
        await luv_config_collection.update_one({"_id": "luv_config"}, {"$set": cfg}, upsert=True) 
        await update.message.reply_text(f"‚úì {name}: {weight}% | {price}g", parse_mode="HTML") 
    except: 
        await update.message.reply_text("‚äó …™…¥·¥†·¥Ä ü…™·¥Ö ·¥†·¥Ä ü·¥ú·¥áÍú±") 
 
async def luv_reset(update: Update, context: CallbackContext): 
    if str(update.effective_user.id) not in sudo_users: 
        return 
 
    if len(context.args) < 1: 
        await update.message.reply_text("‚äó ·¥úÍú±·¥Ä…¢·¥á: /luvreset <uid>") 
        return 
 
    try: 
        target_uid = int(context.args[0]) 
        luv_data = {'characters': [], 'last_reset': None, 'refresh_count': 0, 'purchased': []} 
        await update_luv_data(target_uid, luv_data) 
        await update.message.reply_text(f"‚úì  Ä·¥áÍú±·¥á·¥õ ·¥úÍú±·¥á Ä {target_uid}") 
    except: 
        await update.message.reply_text("‚äó …™…¥·¥†·¥Ä ü…™·¥Ö ·¥ú…™·¥Ö") 
 
async def luv_rmrarity(update: Update, context: CallbackContext): 
    if str(update.effective_user.id) not in sudo_users: 
        return 
 
    if len(context.args) < 1: 
        await update.message.reply_text("‚äó ·¥úÍú±·¥Ä…¢·¥á: /luvrmrarity <rarity_name>") 
        return 
 
    try: 
        name = " ".join(context.args) 
        cfg = await get_config() 
 
        if name not in cfg['rarities']: 
            await update.message.reply_text(f"‚äó  Ä·¥Ä Ä…™·¥õ è '<b>{name}</b>' …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö", parse_mode="HTML") 
            return 
 
        if len(cfg['rarities']) <= 1: 
            await update.message.reply_text("‚äó ·¥Ñ·¥Ä…¥…¥·¥è·¥õ  Ä·¥á·¥ç·¥è·¥†·¥á  ü·¥ÄÍú±·¥õ  Ä·¥Ä Ä…™·¥õ è!") 
            return 
 
        del cfg['rarities'][name] 
        await luv_config_collection.update_one({"_id": "luv_config"}, {"$set": cfg}, upsert=True) 
        await update.message.reply_text(f"‚úì  Ä·¥á·¥ç·¥è·¥†·¥á·¥Ö '<b>{name}</b>'", parse_mode="HTML") 
    except Exception as e: 
        await update.message.reply_text(f"‚äó ·¥á Ä Ä·¥è Ä: {str(e)}") 
 
# Register handlers 
application.add_handler(CommandHandler("ps", luv, block=False)) 
application.add_handler(CommandHandler("pstats", luv_stats, block=False)) 
application.add_handler(CommandHandler("phelp", luv_help, block=False)) 
application.add_handler(CommandHandler("pview", luv_view, block=False)) 
application.add_handler(CommandHandler("pconfig", luv_config, block=False)) 
application.add_handler(CommandHandler("prarity", luv_rarity, block=False)) 
application.add_handler(CommandHandler("prmrarity", luv_rmrarity, block=False)) 
application.add_handler(CommandHandler("preset", luv_reset, block=False)) 
application.add_handler(CallbackQueryHandler(luv_callback, pattern=r"^luv_", block=False))