import random
from datetime import datetime, timedelta
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update, InputMediaPhoto
from telegram.ext import CallbackContext, CommandHandler, CallbackQueryHandler
from shivu import application, db, user_collection

collection = db['anime_characters_lol']
ps_config_collection = db['ps_config']
sudo_users = ["8297659126", "8420981179", "5147822244"]

DEFAULT_CONFIG = {
    "rarities": {
        "üü¢ Common": {"weight": 60, "price": 2000},
        "üü£ Rare": {"weight": 25, "price": 5000},
        "üü° Legendary": {"weight": 10, "price": 10000},
        "üíÆ Special Edition": {"weight": 5, "price": 25000}
    },
    "refresh_cost": 20000,
    "refresh_limit": 2,
    "store_items": 3,
    "cooldown_hours": 24
}

async def get_config():
    cfg = await ps_config_collection.find_one({"_id": "ps_config"})
    if not cfg:
        await ps_config_collection.insert_one({"_id": "ps_config", **DEFAULT_CONFIG})
        return DEFAULT_CONFIG
    return cfg

async def get_rarity(cfg):
    rarities = cfg['rarities']
    return random.choices(list(rarities.keys()), [rarities[r]['weight'] for r in rarities], k=1)[0]

async def generate_chars(uid, cfg):
    chars = []
    for _ in range(cfg.get('store_items', 3)):
        rarity = await get_rarity(cfg)
        pipe = [{'$match': {'rarity': rarity}}, {'$sample': {'size': 1}}]
        char = await collection.aggregate(pipe).to_list(length=1)
        if char:
            chars.append(char[0])
    return chars

async def get_ps_data(uid):
    user = await user_collection.find_one({"id": uid})
    return user.get('private_store', {'characters': [], 'last_reset': None, 'refresh_count': 0, 'purchased': []}) if user else None

async def update_ps_data(uid, data):
    await user_collection.update_one({"id": uid}, {"$set": {"private_store": data}}, upsert=True)

def time_left(target):
    if not target:
        return "·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á …¥·¥è·¥°"
    if isinstance(target, str):
        target = datetime.fromisoformat(target)
    diff = target - datetime.utcnow()
    if diff.total_seconds() <= 0:
        return "·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á …¥·¥è·¥°"
    h, m = int(diff.total_seconds() // 3600), int((diff.total_seconds() % 3600) // 60)
    return f"{h} ú {m}·¥ç"

async def build_caption(char, cfg, page, total, ps_data, balance):
    cid = char.get("id") or char.get("_id")
    name = char.get("name", "Unknown")
    anime = char.get("anime", "Unknown")
    rarity = char.get("rarity", "Unknown")
    price = cfg['rarities'].get(rarity, {}).get('price', 0)
    
    refresh_left = max(0, cfg.get('refresh_limit', 2) - ps_data.get('refresh_count', 0))
    last_reset = ps_data.get('last_reset')
    if last_reset:
        if isinstance(last_reset, str):
            last_reset = datetime.fromisoformat(last_reset)
        next_reset = last_reset + timedelta(hours=cfg.get('cooldown_hours', 24))
        time_rem = time_left(next_reset)
    else:
        time_rem = "·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á …¥·¥è·¥°"
    
    purchased = ps_data.get('purchased', [])
    status = "‚äó ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥è·¥°…¥·¥á·¥Ö" if cid in purchased else f"‚äô {price} …¢·¥è ü·¥Ö"
    
    return (
        f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n"
        f"‚îÇ   Ôº∞Ôº≤Ôº©Ôº∂Ôº°Ôº¥Ôº• Ôº≥Ôº¥ÔºØÔº≤Ôº•   ‚îÇ\n"
        f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n"
        f"‚ü° …¥·¥Ä·¥ç·¥á: <b>{name}</b>\n"
        f"‚ü° ·¥Ä…¥…™·¥ç·¥á: <code>{anime}</code>\n"
        f"‚ü°  Ä·¥Ä Ä…™·¥õ è: {rarity}\n"
        f"‚ü° ·¥ò Ä…™·¥Ñ·¥á: {status}\n"
        f"‚ü° …™·¥Ö: <code>{cid}</code>\n\n"
        f"‚ü°  Ä·¥á“ì Ä·¥áÍú± ú·¥áÍú±  ü·¥áÍú∞·¥õ: {refresh_left}/{cfg.get('refresh_limit', 2)}\n"
        f"‚ü° …¥·¥áx·¥õ  Ä·¥áÍú±·¥á·¥õ: {time_rem}\n\n"
        f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        f"‚ü° ·¥ò·¥Ä…¢·¥á: {page}/{total}\n"
        f"‚ü°  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á: {balance} …¢·¥è ü·¥Ö"
    ), char.get("img_url", ""), price, cid in purchased

async def ps(update: Update, context: CallbackContext):
    uid = update.effective_user.id
    cfg = await get_config()
    user = await user_collection.find_one({"id": uid})
    
    if not user:
        await update.message.reply_text("‚äó Íú±·¥õ·¥Ä Ä·¥õ ·¥õ ú·¥á  ô·¥è·¥õ Íú∞…™ ÄÍú±·¥õ! ·¥úÍú±·¥á /start")
        return
    
    balance = user.get('balance', 0)
    ps_data = await get_ps_data(uid)
    
    cooldown = cfg.get('cooldown_hours', 24)
    last_reset = ps_data.get('last_reset')
    needs_reset = True
    
    if last_reset:
        if isinstance(last_reset, str):
            last_reset = datetime.fromisoformat(last_reset)
        needs_reset = (datetime.utcnow() - last_reset).total_seconds() >= (cooldown * 3600)
    
    if needs_reset or not ps_data.get('characters'):
        chars = await generate_chars(uid, cfg)
        if not chars:
            await update.message.reply_text("‚äó Íú∞·¥Ä…™ ü·¥á·¥Ö ·¥õ·¥è …¢·¥á…¥·¥á Ä·¥Ä·¥õ·¥á Íú±·¥õ·¥è Ä·¥á")
            return
        ps_data = {'characters': chars, 'last_reset': datetime.utcnow().isoformat(), 'refresh_count': 0, 'purchased': []}
        await update_ps_data(uid, ps_data)
    
    chars = ps_data.get('characters', [])
    if not chars:
        await update.message.reply_text("‚äó …¥·¥è ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú± ·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á")
        return
    
    context.user_data['ps_page'] = 0
    context.user_data['ps_chars'] = chars
    
    char = chars[0]
    caption, img, price, owned = await build_caption(char, cfg, 1, len(chars), ps_data, balance)
    cid = char.get("id") or char.get("_id")
    
    btns = []
    if not owned:
        btns.append([InlineKeyboardButton("‚äô  ô·¥ú è", callback_data=f"ps_buy_{cid}")])
    
    nav = []
    if len(chars) > 1:
        refresh_left = max(0, cfg.get('refresh_limit', 2) - ps_data.get('refresh_count', 0))
        nav.append(InlineKeyboardButton("‚ü≤  Ä·¥á“ì Ä·¥áÍú± ú" if refresh_left > 0 else "‚ü≤ ·¥úÍú±·¥á·¥Ö", 
                                        callback_data="ps_refresh" if refresh_left > 0 else "ps_nope"))
        nav.append(InlineKeyboardButton("…¥·¥áx·¥õ ‚ä≥", callback_data="ps_page_1"))
        btns.append(nav)
    else:
        refresh_left = max(0, cfg.get('refresh_limit', 2) - ps_data.get('refresh_count', 0))
        btns.append([InlineKeyboardButton("‚ü≤  Ä·¥á“ì Ä·¥áÍú± ú" if refresh_left > 0 else "‚ü≤ ·¥úÍú±·¥á·¥Ö", 
                                         callback_data="ps_refresh" if refresh_left > 0 else "ps_nope")])
    
    btns.append([InlineKeyboardButton("‚äó ·¥Ñ ü·¥èÍú±·¥á", callback_data="ps_close")])
    
    msg = await update.message.reply_photo(photo=img, caption=caption, parse_mode="HTML", 
                                           reply_markup=InlineKeyboardMarkup(btns))
    context.user_data['ps_msg_id'] = msg.message_id

async def ps_callback(update: Update, context: CallbackContext):
    q = update.callback_query
    await q.answer()
    uid = q.from_user.id
    data = q.data
    cfg = await get_config()
    
    async def render_page(page):
        chars = context.user_data.get('ps_chars', [])
        if not chars or page >= len(chars):
            await q.answer("‚äó …™…¥·¥†·¥Ä ü…™·¥Ö ·¥ò·¥Ä…¢·¥á", show_alert=True)
            return
        
        context.user_data['ps_page'] = page
        char = chars[page]
        user = await user_collection.find_one({"id": uid})
        balance = user.get('balance', 0) if user else 0
        ps_data = await get_ps_data(uid)
        
        caption, img, price, owned = await build_caption(char, cfg, page + 1, len(chars), ps_data, balance)
        cid = char.get("id") or char.get("_id")
        
        btns = []
        if not owned:
            btns.append([InlineKeyboardButton("‚äô  ô·¥ú è", callback_data=f"ps_buy_{cid}")])
        
        nav = []
        if len(chars) > 1:
            if page > 0:
                nav.append(InlineKeyboardButton("‚ä≤ ·¥ò Ä·¥á·¥†", callback_data=f"ps_page_{page-1}"))
            refresh_left = max(0, cfg.get('refresh_limit', 2) - ps_data.get('refresh_count', 0))
            nav.append(InlineKeyboardButton("‚ü≤  Ä·¥á“ì Ä·¥áÍú± ú" if refresh_left > 0 else "‚ü≤ ·¥úÍú±·¥á·¥Ö", 
                                           callback_data="ps_refresh" if refresh_left > 0 else "ps_nope"))
            if page < len(chars) - 1:
                nav.append(InlineKeyboardButton("…¥·¥áx·¥õ ‚ä≥", callback_data=f"ps_page_{page+1}"))
            btns.append(nav)
        
        btns.append([InlineKeyboardButton("‚äó ·¥Ñ ü·¥èÍú±·¥á", callback_data="ps_close")])
        
        try:
            await q.edit_message_media(media=InputMediaPhoto(media=img, caption=caption, parse_mode="HTML"),
                                       reply_markup=InlineKeyboardMarkup(btns))
        except:
            try:
                await q.edit_message_caption(caption=caption, parse_mode="HTML", 
                                            reply_markup=InlineKeyboardMarkup(btns))
            except:
                pass
    
    if data.startswith("ps_page_"):
        await render_page(int(data.split("_")[2]))
    
    elif data == "ps_refresh":
        user = await user_collection.find_one({"id": uid})
        if not user:
            await q.answer("‚äó ·¥úÍú±·¥á Ä …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö", show_alert=True)
            return
        
        ps_data = await get_ps_data(uid)
        refresh_left = max(0, cfg.get('refresh_limit', 2) - ps_data.get('refresh_count', 0))
        
        if refresh_left <= 0:
            await q.answer("‚äó …¥·¥è  Ä·¥á“ì Ä·¥áÍú± ú·¥áÍú±  ü·¥áÍú∞·¥õ!", show_alert=True)
            return
        
        cost = cfg.get('refresh_cost', 20000)
        balance = user.get('balance', 0)
        
        if balance < cost:
            await q.answer(f"‚äó …¥·¥á·¥á·¥Ö {cost} …¢·¥è ü·¥Ö!", show_alert=True)
            return
        
        btns = [[InlineKeyboardButton("‚úì ·¥Ñ·¥è…¥Íú∞…™ Ä·¥ç", callback_data="ps_ref_ok"),
                 InlineKeyboardButton("‚úó ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü", callback_data="ps_ref_no")]]
        
        await q.edit_message_caption(
            caption=f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n"
                    f"‚îÇ   Ôº£ÔºØÔºÆÔº¶Ôº©Ôº≤Ôº≠ Ôº≤Ôº•Ôº¶Ôº≤Ôº•Ôº≥Ôº®   ‚îÇ\n"
                    f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n"
                    f"‚ü° ·¥Ñ·¥èÍú±·¥õ: <b>{cost}</b> …¢·¥è ü·¥Ö\n"
                    f"‚ü°  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á: <b>{balance}</b> …¢·¥è ü·¥Ö\n"
                    f"‚ü°  Ä·¥áÍú∞ Ä·¥áÍú± ú·¥áÍú±  ü·¥áÍú∞·¥õ: {refresh_left-1}/{cfg.get('refresh_limit', 2)}\n\n"
                    f"…¢·¥á…¥·¥á Ä·¥Ä·¥õ·¥á 3 …¥·¥á·¥°  Ä·¥Ä…¥·¥Ö·¥è·¥ç ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±?",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup(btns)
        )
    
    elif data == "ps_ref_ok":
        user = await user_collection.find_one({"id": uid})
        ps_data = await get_ps_data(uid)
        cost = cfg.get('refresh_cost', 20000)
        balance = user.get('balance', 0)
        
        if balance < cost:
            await q.answer("‚äó …™…¥Íú±·¥úÍú∞Íú∞…™·¥Ñ…™·¥á…¥·¥õ  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á!", show_alert=True)
            return
        
        await user_collection.update_one({"id": uid}, {"$inc": {"balance": -cost}})
        
        # Refresh animation
        await q.edit_message_caption(
            caption="‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n"
                    "‚îÇ   ‚ü≤ Ôº≤Ôº•Ôº¶Ôº≤Ôº•Ôº≥Ôº®Ôº©ÔºÆÔºß...   ‚îÇ\n"
                    "‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n"
                    "‚ü° …¢·¥á…¥·¥á Ä·¥Ä·¥õ…™…¥…¢ …¥·¥á·¥° ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±...",
            parse_mode="HTML"
        )
        
        chars = await generate_chars(uid, cfg)
        if not chars:
            await q.answer("‚äó Íú∞·¥Ä…™ ü·¥á·¥Ö ·¥õ·¥è …¢·¥á…¥·¥á Ä·¥Ä·¥õ·¥á", show_alert=True)
            return
        
        ps_data['characters'] = chars
        ps_data['refresh_count'] = ps_data.get('refresh_count', 0) + 1
        ps_data['purchased'] = []
        await update_ps_data(uid, ps_data)
        
        context.user_data['ps_chars'] = chars
        context.user_data['ps_page'] = 0
        
        await q.answer("‚úì Íú±·¥õ·¥è Ä·¥á  Ä·¥á“ì Ä·¥áÍú± ú·¥á·¥Ö!")
        await render_page(0)
    
    elif data == "ps_ref_no":
        await render_page(context.user_data.get('ps_page', 0))
    
    elif data == "ps_nope":
        await q.answer("‚äó …¥·¥è  Ä·¥á“ì Ä·¥áÍú± ú·¥áÍú±  ü·¥áÍú∞·¥õ!", show_alert=True)
    
    elif data.startswith("ps_buy_"):
        cid = data.split("_", 2)[2]
        chars = context.user_data.get('ps_chars', [])
        char = next((c for c in chars if (c.get("id") or c.get("_id")) == cid), None)
        
        if not char:
            await q.answer("‚äó ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á Ä …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö", show_alert=True)
            return
        
        ps_data = await get_ps_data(uid)
        if cid in ps_data.get('purchased', []):
            await q.answer("‚äó ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥ò·¥ú Ä·¥Ñ ú·¥ÄÍú±·¥á·¥Ö!", show_alert=True)
            return
        
        rarity = char.get('rarity', 'Unknown')
        price = cfg['rarities'].get(rarity, {}).get('price', 0)
        
        btns = [[InlineKeyboardButton("‚úì ·¥Ñ·¥è…¥Íú∞…™ Ä·¥ç", callback_data=f"ps_ok_{cid}"),
                 InlineKeyboardButton("‚úó ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü", callback_data="ps_buy_no")]]
        
        await q.edit_message_caption(
            caption=f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n"
                    f"‚îÇ   Ôº£ÔºØÔºÆÔº¶Ôº©Ôº≤Ôº≠ Ôº∞ÔºµÔº≤Ôº£Ôº®Ôº°Ôº≥Ôº•   ‚îÇ\n"
                    f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n"
                    f"‚ü° …¥·¥Ä·¥ç·¥á: <b>{char['name']}</b>\n"
                    f"‚ü°  Ä·¥Ä Ä…™·¥õ è: {rarity}\n"
                    f"‚ü° ·¥ò Ä…™·¥Ñ·¥á: <b>{price}</b> …¢·¥è ü·¥Ö\n\n"
                    f"·¥Ñ·¥è…¥Íú∞…™ Ä·¥ç ·¥ò·¥ú Ä·¥Ñ ú·¥ÄÍú±·¥á?",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup(btns)
        )
    
    elif data.startswith("ps_ok_"):
        cid = data.split("_", 2)[2]
        chars = context.user_data.get('ps_chars', [])
        char = next((c for c in chars if (c.get("id") or c.get("_id")) == cid), None)
        
        if not char:
            await q.answer("‚äó ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á Ä …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö", show_alert=True)
            return
        
        user = await user_collection.find_one({"id": uid})
        ps_data = await get_ps_data(uid)
        
        if cid in ps_data.get('purchased', []):
            await q.answer("‚äó ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥ò·¥ú Ä·¥Ñ ú·¥ÄÍú±·¥á·¥Ö!", show_alert=True)
            return
        
        rarity = char.get('rarity', 'Unknown')
        price = cfg['rarities'].get(rarity, {}).get('price', 0)
        balance = user.get('balance', 0)
        
        if balance < price:
            await q.answer("‚äó …™…¥Íú±·¥úÍú∞Íú∞…™·¥Ñ…™·¥á…¥·¥õ  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á!", show_alert=True)
            await q.edit_message_caption(
                caption=f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n"
                        f"‚îÇ   ‚äó …™…¥Íú±·¥úÍú∞Íú∞…™·¥Ñ…™·¥á…¥·¥õ …¢·¥è ü·¥Ö   ‚îÇ\n"
                        f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n"
                        f"‚ü° …¥·¥á·¥á·¥Ö: <b>{price}</b> …¢·¥è ü·¥Ö\n"
                        f"‚ü°  ú·¥Ä·¥†·¥á: <b>{balance}</b> …¢·¥è ü·¥Ö\n\n"
                        f"·¥úÍú±·¥á /bal ·¥õ·¥è ·¥Ñ ú·¥á·¥Ñ·¥ã  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á",
                parse_mode="HTML"
            )
            return
        
        # Purchase
        await user_collection.update_one({"id": uid}, 
                                         {"$inc": {"balance": -price}, "$push": {"characters": char}})
        
        if 'purchased' not in ps_data:
            ps_data['purchased'] = []
        ps_data['purchased'].append(cid)
        await update_ps_data(uid, ps_data)
        
        btns = [[InlineKeyboardButton("‚äô ·¥ç·¥Ä…™…¥ Íú± ú·¥è·¥ò", callback_data="ps_main"),
                 InlineKeyboardButton("‚äó ·¥Ñ ü·¥èÍú±·¥á", callback_data="ps_close")]]
        
        await q.edit_message_caption(
            caption=f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n"
                    f"‚îÇ   ‚úì Ôº∞ÔºµÔº≤Ôº£Ôº®Ôº°Ôº≥Ôº• Ôº≥ÔºµÔº£Ôº£Ôº•Ôº≥Ôº≥   ‚îÇ\n"
                    f"‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n"
                    f"‚ü° …¥·¥Ä·¥ç·¥á: <b>{char['name']}</b>\n"
                    f"‚ü° ·¥ò·¥Ä…™·¥Ö: <b>{price}</b> …¢·¥è ü·¥Ö\n"
                    f"‚ü°  Ä·¥á·¥ç·¥Ä…™…¥…™…¥…¢: <b>{balance - price}</b> …¢·¥è ü·¥Ö\n\n"
                    f"·¥Ä·¥Ö·¥Ö·¥á·¥Ö ·¥õ·¥è  è·¥è·¥ú Ä  ú·¥Ä Ä·¥á·¥ç!",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup(btns)
        )
        await q.answer("‚úì ·¥ò·¥ú Ä·¥Ñ ú·¥ÄÍú±·¥á·¥Ö!")
    
    elif data == "ps_buy_no":
        await render_page(context.user_data.get('ps_page', 0))
    
    elif data == "ps_main":
        await render_page(0)
    
    elif data == "ps_close":
        try:
            await q.message.delete()
        except:
            await q.edit_message_caption("Íú±·¥õ·¥è Ä·¥á ·¥Ñ ü·¥èÍú±·¥á·¥Ö")

# Admin commands (shortened)
async def ps_view(update: Update, context: CallbackContext):
    if str(update.effective_user.id) not in sudo_users:
        return
    cfg = await get_config()
    rarities = "\n".join([f"‚ü° {r}: {d['weight']}% | {d['price']}g" for r, d in cfg['rarities'].items()])
    await update.message.reply_text(
        f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ   ·¥òÍú± ·¥Ñ·¥è…¥Íú∞…™…¢   ‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n"
        f"‚ü°  Ä·¥á“ì Ä·¥áÍú± ú ·¥Ñ·¥èÍú±·¥õ: {cfg.get('refresh_cost')}\n"
        f"‚ü°  Ä·¥á“ì Ä·¥áÍú± ú  ü…™·¥ç…™·¥õ: {cfg.get('refresh_limit')}\n"
        f"‚ü° …™·¥õ·¥á·¥çÍú±: {cfg.get('store_items')}\n"
        f"‚ü° ·¥Ñ·¥è·¥è ü·¥Ö·¥è·¥°…¥: {cfg.get('cooldown_hours')} ú\n\n{rarities}",
        parse_mode="HTML"
    )

async def ps_stats(update: Update, context: CallbackContext):
    uid = update.effective_user.id
    user = await user_collection.find_one({"id": uid})
    if not user:
        await update.message.reply_text("‚äó ·¥úÍú±·¥á /start Íú∞…™ ÄÍú±·¥õ")
        return
    
    ps_data = await get_ps_data(uid)
    cfg = await get_config()
    refresh_left = max(0, cfg.get('refresh_limit', 2) - ps_data.get('refresh_count', 0))
    
    last_reset = ps_data.get('last_reset')
    if last_reset:
        if isinstance(last_reset, str):
            last_reset = datetime.fromisoformat(last_reset)
        next_reset = last_reset + timedelta(hours=cfg.get('cooldown_hours', 24))
        time_rem = time_left(next_reset)
    else:
        time_rem = "·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á …¥·¥è·¥°"
    
    await update.message.reply_text(
        f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ    è·¥è·¥ú Ä ·¥òÍú± Íú±·¥õ·¥Ä·¥õÍú±   ‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n"
        f"‚ü° ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±: {len(ps_data.get('characters', []))}\n"
        f"‚ü°  Ä·¥á“ì Ä·¥áÍú± ú·¥áÍú±: {refresh_left}/{cfg.get('refresh_limit', 2)}\n"
        f"‚ü° …¥·¥áx·¥õ  Ä·¥áÍú±·¥á·¥õ: {time_rem}\n"
        f"‚ü°  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á: {user.get('balance', 0)} …¢·¥è ü·¥Ö\n\n"
        f"·¥úÍú±·¥á /ps ·¥õ·¥è ·¥è·¥ò·¥á…¥ Íú±·¥õ·¥è Ä·¥á!",
        parse_mode="HTML"
    )

async def ps_help(update: Update, context: CallbackContext):
    msg = (
        f"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ   ·¥òÍú±  ú·¥á ü·¥ò   ‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n"
        f"<b>·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú±:</b>\n"
        f"‚ü° /ps - ·¥è·¥ò·¥á…¥ Íú±·¥õ·¥è Ä·¥á\n"
        f"‚ü° /psstats - ·¥†…™·¥á·¥° Íú±·¥õ·¥Ä·¥õÍú±\n\n"
        f"<b> ú·¥è·¥° …™·¥õ ·¥°·¥è Ä·¥ãÍú±:</b>\n"
        f"‚ü° …¢·¥á·¥õ 3  Ä·¥Ä…¥·¥Ö·¥è·¥ç ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú± ·¥á·¥†·¥á Ä è 24 ú\n"
        f"‚ü°  Ä·¥á“ì Ä·¥áÍú± ú ·¥ú·¥ò ·¥õ·¥è 2x (·¥Ñ·¥èÍú±·¥õÍú± …¢·¥è ü·¥Ö)\n"
        f"‚ü°  ô·¥ú è ·¥°…™·¥õ ú …¢·¥è ü·¥Ö\n"
        f"‚ü° ·¥Ä·¥ú·¥õ·¥è  Ä·¥áÍú±·¥á·¥õ ·¥ÄÍú∞·¥õ·¥á Ä ·¥Ñ·¥è·¥è ü·¥Ö·¥è·¥°…¥"
    )
    
    uid = update.effective_user.id
    if str(uid) in sudo_users:
        msg += (
            f"\n\n<b>·¥Ä·¥Ö·¥ç…™…¥:</b>\n"
            f"‚ü° /psview - ·¥†…™·¥á·¥° ·¥Ñ·¥è…¥Íú∞…™…¢\n"
            f"‚ü° /psconfig <key> <val>\n"
            f"‚ü° /psrarity <name> <w> <p>\n"
            f"‚ü° /psreset <uid>"
        )
    
    await update.message.reply_text(msg, parse_mode="HTML")

async def ps_config(update: Update, context: CallbackContext):
    if str(update.effective_user.id) not in sudo_users:
        return
    
    if len(context.args) < 2:
        await update.message.reply_text("‚äó ·¥úÍú±·¥Ä…¢·¥á: /psconfig <key> <value>\n·¥ã·¥á èÍú±: refresh_cost, refresh_limit, store_items, cooldown_hours")
        return
    
    try:
        key, val = context.args[0], int(context.args[1])
        if key not in ['refresh_cost', 'refresh_limit', 'store_items', 'cooldown_hours']:
            await update.message.reply_text("‚äó …™…¥·¥†·¥Ä ü…™·¥Ö ·¥ã·¥á è")
            return
        
        cfg = await get_config()
        cfg[key] = val
        await ps_config_collection.update_one({"_id": "ps_config"}, {"$set": cfg}, upsert=True)
        await update.message.reply_text(f"‚úì {key} = {val}", parse_mode="HTML")
    except:
        await update.message.reply_text("‚äó …™…¥·¥†·¥Ä ü…™·¥Ö ·¥†·¥Ä ü·¥ú·¥á")

async def ps_rarity(update: Update, context: CallbackContext):
    if str(update.effective_user.id) not in sudo_users:
        return
    
    if len(context.args) < 3:
        await update.message.reply_text("‚äó ·¥úÍú±·¥Ä…¢·¥á: /psrarity <name> <weight> <price>")
        return
    
    try:
        name = " ".join(context.args[:-2])
        weight, price = int(context.args[-2]), int(context.args[-1])
        
        cfg = await get_config()
        if name not in cfg['rarities']:
            cfg['rarities'][name] = {}
        cfg['rarities'][name] = {'weight': weight, 'price': price}
        
        await ps_config_collection.update_one({"_id": "ps_config"}, {"$set": cfg}, upsert=True)
        await update.message.reply_text(f"‚úì {name}: {weight}% | {price}g", parse_mode="HTML")
    except:
        await update.message.reply_text("‚äó …™…¥·¥†·¥Ä ü…™·¥Ö ·¥†·¥Ä ü·¥ú·¥áÍú±")

async def ps_reset(update: Update, context: CallbackContext):
    if str(update.effective_user.id) not in sudo_users:
        return
    
    if len(context.args) < 1:
        await update.message.reply_text("‚äó ·¥úÍú±·¥Ä…¢·¥á: /psreset <uid>")
        return
    
    try:
        target_uid = int(context.args[0])
        ps_data = {'characters': [], 'last_reset': None, 'refresh_count': 0, 'purchased': []}
        await update_ps_data(target_uid, ps_data)
        await update.message.reply_text(f"‚úì  Ä·¥áÍú±·¥á·¥õ ·¥úÍú±·¥á Ä {target_uid}")
    except:
        await update.message.reply_text("‚äó …™…¥·¥†·¥Ä ü…™·¥Ö ·¥ú…™·¥Ö")

async def ps_rmrarity(update: Update, context: CallbackContext):
    if str(update.effective_user.id) not in sudo_users:
        return
    
    if len(context.args) < 1:
        await update.message.reply_text("‚äó ·¥úÍú±·¥Ä…¢·¥á: /psrmrarity <rarity_name>")
        return
    
    try:
        name = " ".join(context.args)
        cfg = await get_config()
        
        if name not in cfg['rarities']:
            await update.message.reply_text(f"‚äó  Ä·¥Ä Ä…™·¥õ è '<b>{name}</b>' …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö", parse_mode="HTML")
            return
        
        if len(cfg['rarities']) <= 1:
            await update.message.reply_text("‚äó ·¥Ñ·¥Ä…¥…¥·¥è·¥õ  Ä·¥á·¥ç·¥è·¥†·¥á  ü·¥ÄÍú±·¥õ  Ä·¥Ä Ä…™·¥õ è!")
            return
        
        del cfg['rarities'][name]
        await ps_config_collection.update_one({"_id": "ps_config"}, {"$set": cfg}, upsert=True)
        await update.message.reply_text(f"‚úì  Ä·¥á·¥ç·¥è·¥†·¥á·¥Ö '<b>{name}</b>'", parse_mode="HTML")
    except Exception as e:
        await update.message.reply_text(f"‚äó ·¥á Ä Ä·¥è Ä: {str(e)}")

# Register handlers
application.add_handler(CommandHandler("ps", ps, block=False))
application.add_handler(CommandHandler("psstats", ps_stats, block=False))
application.add_handler(CommandHandler("pshelp", ps_help, block=False))
application.add_handler(CommandHandler("psview", ps_view, block=False))
application.add_handler(CommandHandler("psconfig", ps_config, block=False))
application.add_handler(CommandHandler("psrarity", ps_rarity, block=False))
application.add_handler(CommandHandler("psrmrarity", ps_rmrarity, block=False))
application.add_handler(CommandHandler("psreset", ps_reset, block=False))
application.add_handler(CallbackQueryHandler(ps_callback, pattern=r"^pss_", block=False))